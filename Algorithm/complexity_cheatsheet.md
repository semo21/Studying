# ⏱️ 시간 복잡도 & 🧠 메모리 계산 치트시트
알고리즘 문제 풀이(BOJ / 코딩 테스트 / 실무) 범용 가이드

---

## 1. 시간 복잡도 판단의 절대 기준

### 기본 전제 (C++ 기준)
- **1초 ≈ 1억(10^8) 연산**
- 보통 시간 제한:
  - 1초 → 약 1e8
  - 2초 → 약 2e8
  - 3초 → 약 3e8

> 이 기준으로 “된다 / 안 된다”를 빠르게 판단한다.

---

## 2. N 최대값에 따른 알고리즘 선택

| N 최대값      | 안전한 시간 복잡도   |
| ------------- | -------------------- |
| ≤ 1,000       | O(N²)                |
| ≤ 10,000      | O(N²) (위험)         |
| ≤ 100,000     | O(N log N)           |
| ≤ 1,000,000   | O(N log N) 또는 O(N) |
| ≤ 10,000,000  | O(N) 또는 특수 정렬  |
| ≤ 100,000,000 | O(N)만 가능          |

---

## 3. 대표 알고리즘 시간 복잡도

| 알고리즘                  | 시간 복잡도 |
| ------------------------- | ----------- |
| 버블 / 삽입 / 선택 정렬   | O(N²)       |
| 병합 정렬                 | O(N log N)  |
| 퀵 정렬 (평균)            | O(N log N)  |
| 힙 정렬                   | O(N log N)  |
| 인트로 소트 (`std::sort`) | O(N log N)  |
| 카운팅 정렬               | O(N + K)    |
| 이분 탐색                 | O(log N)    |
| BFS / DFS                 | O(N + E)    |

> ※ 정렬 문제에서 N ≥ 100,000이면 O(N²)은 즉시 제외

---

## 4. 실제 연산 수 계산 예시

### O(N²)
N = 100,000
N² = 10,000,000,000 (100억) → 시간 초과

### O(N log N)
N = 100,000
log2(N) ≈ 17
100,000 × 17 ≈ 1,700,000 → 통과

### O(N)
N = 10,000,000
≈ 10,000,000 연산 → 통과

---

## 5. for문으로 시간 복잡도 판단하기

### N²
```cpp
for(int i = 0; i < N; i++)
    for(int j = 0; j < N; j++)
```

### N² (삼각형 형태)
```cpp
for(int i = 0; i < N; i++)
    for(int j = 0; j < i; j++)
```

### N
```cpp
for(int i = 0; i < N; i++)
    for(int j = 0; j < 10; j++)
```
---
## 6. 메모리 계산 기본 공식

> 배열 크기 × 자료형 크기

기본 자료형 크기
| 자료형    | 크기                      |
| --------- | ------------------------- |
| int       | 4 byte                    |
| long long | 8 byte                    |
| char      | 1 byte                    |
| bool      | 1 byte (구현에 따라 다름) |


## 7. 메모리 계산 예시
### vector<int> arr(1,000,000)
```arduino
1,000,000 × 4 byte = 4 MB
```

### 병합 정렬 (추가 배열 필요)
```makefile
arr  = 4 MB
temp = 4 MB
총합 = 8 MB
```
⚠️ 메모리 제한 8MB면 초과 위험

### 카운팅 정렬 배열
```arduino
int cnt[10001]
10001 × 4 byte ≈ 40 KB
```
→ 매우 안전

---

## 8. 재귀와 메모리

- 병합 정렬 재귀 깊이: log2(N) → 안전
- DFS가 깊이 N까지 가는 경우 → 스택 오버플로우 위험
- 공간 복잡도도 함께 고려 (추가 배열, 방문 배열 등)

---

## 9. 문제를 보자마자 체크할 리스트
### 1. N의 최대값은?
### 2. 시간 제한은?
### 3. O(N²) 가능한가?
### 4. O(N log N)이 필요한가?
### 5. 추가 배열이 필요한가?
### 6. 메모리 제한을 넘지 않는가?
### 7. STL 사용이 가능한가?

---

## 10. 대표 상황별 알고리즘 선택
| 상황           | 선택            |
| -------------- | --------------- |
| 대량 정렬      | std::sort       |
| 값 범위 작음   | 카운팅 정렬     |
| 빠른 검색      | 이분 탐색       |
| 그래프 탐색    | BFS / DFS       |
| 최단 거리      | 다익스트라      |
| 최소 신장 트리 | 크루스칼 / 프림 |

> ex) N=100,000 좌표 정렬 → std::sort + pair
---

### 핵심 암기 요약
- #### 1초 ≈ 1억 연산
- #### N²은 10^5부터 위험
- #### 정렬은 기본 O(N log N)
- #### 메모리는 배열 수 × 자료형 크기
- #### 알고리즘 실력 = 구현 + 판단

---